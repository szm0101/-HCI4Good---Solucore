<<<<<<< HEAD
// @flow strict
import * as React from 'react';
import { type Ref } from './RefTypes';
=======
// @flow

import { type Ref } from "./RefTypes";
>>>>>>> babce7e82dc134320378dfce834b316b88320254

/**
 * Takes an argument and if it's an array, returns the first item in the array,
 * otherwise returns the argument. Used for Preact compatibility.
 */
export const unwrapArray = (arg: *): * => (Array.isArray(arg) ? arg[0] : arg);

/**
 * Takes a maybe-undefined function and arbitrary args and invokes the function
 * only if it is defined.
 */
<<<<<<< HEAD
export const safeInvoke = <F: Function>(
  fn: ?F,
  ...args: Array<mixed>
): $Call<F> => {
  if (typeof fn === 'function') {
    return fn(...args);
  }
};
=======
export const safeInvoke = (fn: ?Function, ...args: *) => {
  if (typeof fn === "function") {
    return fn(...args);
  }
}

/**
 * Does a shallow equality check of two objects by comparing the reference
 * equality of each value.
 */
export const shallowEqual = (objA: { [key: string]: any}, objB: { [key: string]: any}): boolean => {
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);

  if (bKeys.length !== aKeys.length) {
    return false;
  }

  for (var i = 0; i < bKeys.length; i++) {
    var key = aKeys[i];

    if (objA[key] !== objB[key]) {
      return false;
    }
  }

  return true;
}
>>>>>>> babce7e82dc134320378dfce834b316b88320254

/**
 * Sets a ref using either a ref callback or a ref object
 */
<<<<<<< HEAD
export const setRef = (ref: ?Ref, node: ?HTMLElement): void => {
  // if its a function call it
  if (typeof ref === 'function') {
=======
export const setRef = (ref: ?Ref, node: ?HTMLElement) => {
  // if its a function call it
  if (typeof ref === "function") {
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    return safeInvoke(ref, node);
  }
  // otherwise we should treat it as a ref object
  else if (ref != null) {
    ref.current = node;
  }
<<<<<<< HEAD
};

/**
 * Simple ponyfill for Object.fromEntries
 */
export const fromEntries = (
  entries: Array<[string, any]>
): { [key: string]: any } =>
  entries.reduce((acc, [key, value]) => {
    acc[key] = value;
    return acc;
  }, {});

/**
 * Small wrapper around `useLayoutEffect` to get rid of the warning on SSR envs
 */
export const useIsomorphicLayoutEffect:
  | typeof React.useEffect
  | typeof React.useLayoutEffect =
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
    ? React.useLayoutEffect
    : React.useEffect;
=======
}
>>>>>>> babce7e82dc134320378dfce834b316b88320254
