import React from 'react';
<<<<<<< HEAD
import { Popper } from 'react-popper';
import user from '@testing-library/user-event';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import TooltipPopoverWrapper from '../TooltipPopoverWrapper';

describe('Tooltip', () => {
  let element;
  let container;

  beforeEach(() => {
    element = document.createElement('div');
    container = document.createElement('div');
    element.innerHTML =
      '<p id="target">This is the Tooltip <span id="innerTarget">target</span>.</p>';
    element.setAttribute('id', 'testContainer');
    container.setAttribute('id', 'container');
    container.setAttribute('data-testid', 'container');
    element.appendChild(container);
    document.body.appendChild(element);

    jest.useFakeTimers();
    jest.resetModules();
    Popper.mockClear();
=======
import { mount } from 'enzyme';
import { PopperContent } from '../';
import TooltipPopoverWrapper from '../TooltipPopoverWrapper';

describe('Tooltip', () => {
  let isOpen;
  let toggle;
  let element;
  let container;
  let target;
  let innerTarget;
  let synthEvent;

  beforeEach(() => {
    isOpen = false;
    toggle = () => { isOpen = !isOpen; };
    element = document.createElement('div');
    container = document.createElement('div');
    element.innerHTML = '<p id="target">This is the Tooltip <span id="innerTarget">target</span>.</p>';
    element.setAttribute('id', 'testContainer');
    container.setAttribute('id', 'container');
    element.appendChild(container);
    document.body.appendChild(element);
    target = document.getElementById('target');
    innerTarget = document.getElementById('innerTarget');
    synthEvent = { persist: () => {} };

    jest.useFakeTimers();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
  });

  afterEach(() => {
    jest.clearAllTimers();
    document.body.removeChild(element);
<<<<<<< HEAD
    element = null;
    container = null;
  });

  it('should render arrow by default', () => {
    render(
      <TooltipPopoverWrapper target="target" isOpen>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(document.querySelector('.arrow')).toBeInTheDocument();
  });

  it('should render not render arrow if hiderArrow is true', () => {
    render(
      <TooltipPopoverWrapper target="target" isOpen hideArrow>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(document.querySelector('.arrow')).not.toBeInTheDocument();
  });

  it('should not render children if isOpen is false', () => {
    render(
      <TooltipPopoverWrapper target="target" isOpen={false}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(screen.queryByText(/tooltip content/i)).not.toBeInTheDocument();
  });

  it('should render if isOpen is true', () => {
    render(
      <TooltipPopoverWrapper
        target="target"
        isOpen
        className="tooltip show"
        trigger="hover"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(screen.queryByText(/tooltip content/i)).toBeInTheDocument();
    expect(document.querySelector('.tooltip.show')).toBeInTheDocument();
  });

  it('should render with target object', () => {
    render(
      <TooltipPopoverWrapper
        target={document.getElementById('target')}
        isOpen
        className="tooltip show"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(document.getElementsByClassName('tooltip show')).toHaveLength(1);
    expect(screen.queryByText(/tooltip content/i)).toBeInTheDocument();
  });

  it('should toggle isOpen', () => {
    const { rerender } = render(
      <TooltipPopoverWrapper
        target="target"
        isOpen={false}
        className="tooltip show"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(screen.queryByText(/tooltip content/i)).not.toBeInTheDocument();

    rerender(
      <TooltipPopoverWrapper target="target" isOpen className="tooltip show">
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(screen.queryByText(/tooltip content/i)).toBeInTheDocument();

    rerender(
      <TooltipPopoverWrapper
        target="target"
        isOpen={false}
        className="tooltip show"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    jest.advanceTimersByTime(150);
    expect(screen.queryByText(/tooltip content/i)).not.toBeInTheDocument();
  });

  it('should handle target clicks', () => {
    const toggle = jest.fn();
    const { rerender } = render(
      <TooltipPopoverWrapper target="target" isOpen={false} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/this is the Tooltip/i));
    jest.advanceTimersByTime(150);
    expect(toggle).toBeCalled();
    toggle.mockClear();

    rerender(
      <TooltipPopoverWrapper target="target" isOpen toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/this is the Tooltip/i));
    jest.advanceTimersByTime(150);
    expect(toggle).toBeCalled();
  });

  it('should handle inner target clicks', () => {
    const toggle = jest.fn();
    render(
      <TooltipPopoverWrapper target="target" isOpen={false} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/target/i));
    jest.advanceTimersByTime(150);
    expect(toggle).toBeCalled();
  });

  it('should not do anything when document click outside of target', () => {
    const toggle = jest.fn();
    render(
      <TooltipPopoverWrapper target="target" isOpen={false} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByTestId('container'));
    expect(toggle).not.toBeCalled();
  });

  it('should open after receiving single touchstart and single click', () => {
    const toggle = jest.fn();
    render(
      <TooltipPopoverWrapper
        target="target"
        isOpen={false}
        toggle={toggle}
        trigger="click"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/target/i));
    jest.advanceTimersByTime(200);

    expect(toggle).toHaveBeenCalled();

    // TODO: RTL currently doesn't support touch events
  });

  it('should close after receiving single touchstart and single click', () => {
    const toggle = jest.fn();
    render(
      <TooltipPopoverWrapper
        target="target"
        isOpen
        toggle={toggle}
        trigger="click"
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/target/i));
    jest.advanceTimersByTime(200);

    expect(toggle).toHaveBeenCalled();

    // TODO: RTL currently doesn't support touch events
  });

  it('should pass down custom modifiers', () => {
    render(
      <TooltipPopoverWrapper
        isOpen
        target="target"
        modifiers={[
          {
            name: 'offset',
            options: {
              offset: [2, 2],
            },
          },
          {
            name: 'preventOverflow',
            options: {
              boundary: 'viewport',
            },
          },
        ]}
      >
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    expect(Popper.mock.calls[0][0].modifiers).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          name: 'offset',
          options: {
            offset: [2, 2],
          },
        }),
      ]),
    );

    expect(Popper.mock.calls[0][0].modifiers).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          name: 'preventOverflow',
          options: {
            boundary: 'viewport',
          },
        }),
      ]),
    );
  });

  describe('PopperContent', () => {
    beforeEach(() => {
      jest.doMock('../PopperContent', () => {
        return jest.fn((props) => {
          return props.children({
            update: () => {},
            ref: () => {},
            style: {},
            placement: props.placement,
            arrowProps: { ref: () => {}, style: {} },
            isReferenceHidden: false,
          });
        });
      });
    });

    it('should pass down cssModule', () => {
      // eslint-disable-next-line global-require
      const PopperContent = require('../PopperContent');
      // eslint-disable-next-line global-require
      const TooltipPopoverWrapper = require('../TooltipPopoverWrapper').default;

      const cssModule = {
        a: 'b',
      };

      render(
        <TooltipPopoverWrapper isOpen target="target" cssModule={cssModule}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      expect(PopperContent).toBeCalledTimes(1);

      expect(PopperContent.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          cssModule: expect.objectContaining({
            a: 'b',
          }),
        }),
      );
    });

    it('should pass down offset', () => {
      // eslint-disable-next-line global-require
      const PopperContent = require('../PopperContent');
      // eslint-disable-next-line global-require
      const TooltipPopoverWrapper = require('../TooltipPopoverWrapper').default;

      render(
        <TooltipPopoverWrapper isOpen target="target" offset={[0, 12]}>
          Tooltip content
        </TooltipPopoverWrapper>,
      );

      expect(PopperContent).toBeCalledTimes(1);
      expect(PopperContent.mock.calls[0][0].offset).toEqual(
        expect.arrayContaining([0, 12]),
      );
    });

    it('should pass down flip', () => {
      // eslint-disable-next-line global-require
      const PopperContent = require('../PopperContent');
      // eslint-disable-next-line global-require
      const TooltipPopoverWrapper = require('../TooltipPopoverWrapper').default;

      render(
        <TooltipPopoverWrapper isOpen target="target" flip={false}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      expect(PopperContent).toBeCalledTimes(1);
      expect(PopperContent.mock.calls[0][0].flip).toBe(false);
    });

    it('should handle inner target click and correct placement', () => {
      const toggle = jest.fn();
      // eslint-disable-next-line global-require
      const PopperContent = require('../PopperContent');
      // eslint-disable-next-line global-require
      const TooltipPopoverWrapper = require('../TooltipPopoverWrapper').default;

      const { rerender } = render(
        <TooltipPopoverWrapper target="target" isOpen={false} toggle={toggle}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));
      jest.advanceTimersByTime(200);
      expect(toggle).toBeCalled();

      rerender(
        <TooltipPopoverWrapper target="target" isOpen toggle={toggle}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      expect(PopperContent.mock.calls[0][0].target.id).toBe('target');
    });
  });

  it('should not call props.toggle when disabled ', () => {
    const toggle = jest.fn();

    render(
      <TooltipPopoverWrapper target="target" disabled isOpen toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/target/i));

    expect(toggle).not.toHaveBeenCalled();
  });

  it('should not throw when props.toggle is not provided ', () => {
    render(
      <TooltipPopoverWrapper target="target" disabled isOpen>
        Tooltip Content
      </TooltipPopoverWrapper>,
    );

    user.click(screen.getByText(/target/i));
=======
    document.body.innerHTML = '';
    element = null;
    container = null;
    target = null;
    innerTarget = null;
  });

  it('should render with "hideArrow" false by default', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>);

    expect(wrapper.prop('hideArrow')).toBe(false);
  });

  it('should render with "hideArrow" true when "hideArrow" prop is truthy', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} hideArrow>
        Tooltip Content
      </TooltipPopoverWrapper>);

    expect(wrapper.prop('hideArrow')).toBe(true);
  });

  it('should not render children if isOpen is false', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    const Tooltips = document.getElementsByClassName('tooltip');

    expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(0);
    expect(target.className).toBe('');
    expect(Tooltips.length).toBe(0);
    wrapper.detach();
  });

  it('should render if isOpen is true', () => {
    isOpen = true;
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} className="tooltip show" trigger="hover">
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    const Tooltips = document.getElementsByClassName('tooltip');
    expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
    expect(Tooltips.length).toBe(1);
    expect(Tooltips[0].textContent).toBe('Tooltip Content');

    expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
    expect(Tooltips.length).toBe(1);
    expect(Tooltips[0].textContent).toBe('Tooltip Content');

    wrapper.detach();
  });

  it('should render with target object', () => {
    isOpen = true;
    const wrapper = mount(
      <TooltipPopoverWrapper target={document.getElementById('target')} isOpen={isOpen} toggle={toggle} className="tooltip show">
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    const Tooltips = document.getElementsByClassName('tooltip');

    expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
    expect(Tooltips.length).toBe(1);
    expect(Tooltips[0].textContent).toBe('Tooltip Content');

    const tooltips = document.getElementsByClassName('tooltip');
    expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
    expect(tooltips.length).toBe(1);
    expect(tooltips[0].textContent).toBe('Tooltip Content');

    wrapper.detach();
  });

  it('should toggle isOpen', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} className="tooltip show">
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    jest.runTimersToTime(150);
    expect(document.getElementsByClassName('tooltip').length).toBe(0);

    wrapper.setProps({ isOpen: true });
    jest.runTimersToTime(150);
    expect(document.getElementsByClassName('tooltip').length).toBe(1);

    wrapper.setProps({ isOpen: false });
    jest.runTimersToTime(150);
    expect(document.getElementsByClassName('tooltip').length).toBe(0);
    wrapper.detach();
  });

  it('should toggle isOpen', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} className="tooltip show" fade={false}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    expect(document.getElementsByClassName('tooltip').length).toBe(0);
    wrapper.setProps({ isOpen: true });
    jest.runTimersToTime(0); // slight async delay for getDerivedStateFromProps to update isOpen
    expect(document.getElementsByClassName('tooltip').length).toBe(1);
    wrapper.setProps({ isOpen: false });
    jest.runTimersToTime(0);
    expect(document.getElementsByClassName('tooltip').length).toBe(0);
    wrapper.detach();
  });

  it('should handle target clicks', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    expect(isOpen).toBe(false);
    instance.handleDocumentClick({ target: target });
    jest.runTimersToTime(200);
    expect(isOpen).toBe(true);
    instance.handleDocumentClick({ target: target });
    jest.runTimersToTime(200);
    expect(isOpen).toBe(false);

    wrapper.detach();
  });

  it('should handle inner target clicks', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    expect(isOpen).toBe(false);
    instance.handleDocumentClick({ target: innerTarget });
    jest.runTimersToTime(200);
    expect(isOpen).toBe(true);
    wrapper.detach();
  });

  it('should handle inner target click and correct placement', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    expect(isOpen).toBe(false);
    instance.handleDocumentClick({ target: innerTarget });
    jest.runTimersToTime(200);
    expect(isOpen).toBe(true);
    wrapper.setProps({ isOpen: true });
    expect(wrapper.find(PopperContent).props().target.id).toBe('target');
    wrapper.detach();
  });

  it('should not do anything when document click outside of target', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    expect(isOpen).toBe(false);
    instance.handleDocumentClick({ target: container });
    expect(isOpen).toBe(false);

    wrapper.detach();
  });

  it('should clear hide timeout if it exists on target click', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} delay={200}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    instance.hideWithDelay();
    expect(isOpen).toBe(false);
    instance.handleDocumentClick({ target: target });
    jest.runTimersToTime(200);
    expect(isOpen).toBe(true);
    wrapper.setProps({ isOpen: isOpen });
    instance.handleDocumentClick({ target: target });
    expect(isOpen).toBe(true);

    wrapper.detach();
  });

  it('should open after receiving single touchstart and single click', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} trigger="click">
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    expect(isOpen).toBe(false);
    target.dispatchEvent(new Event('touchstart'));
    jest.runTimersToTime(20);
    target.dispatchEvent(new Event('click'));
    jest.runTimersToTime(200);
    expect(isOpen).toBe(true);

    wrapper.detach();
  });

  it('should close after receiving single touchstart and single click', () => {
    isOpen = true;

    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} trigger="click">
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );

    expect(isOpen).toBe(true);
    target.dispatchEvent(new Event('touchstart'));
    jest.runTimersToTime(20);
    target.dispatchEvent(new Event('click'));
    jest.runTimersToTime(200);
    expect(isOpen).toBe(false);

    wrapper.detach();
  });

  it('should pass down custom modifiers', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper
        isOpen
        target="target"
        modifiers={{
          preventOverflow: { boundariesElement: 'viewport' },
          offset: { offset: 2 },
        }}
      >
        Tooltip Content
      </TooltipPopoverWrapper>
    );

    expect(wrapper.find(PopperContent).props().modifiers).toEqual({
      preventOverflow: { boundariesElement: 'viewport' },
      offset: { offset: 2 },
    });

    wrapper.unmount();
  });

  it('should pass down cssModule', () => {
    const cssModule = {};
    const wrapper = mount(
      <TooltipPopoverWrapper
        isOpen
        target="target"
        cssModule={cssModule}
      >
        Tooltip Content
      </TooltipPopoverWrapper>
    );
    expect(wrapper.find(PopperContent).props().cssModule).toBe(cssModule);
    wrapper.unmount();
  });

  it('should pass down offset', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper isOpen target="target" offset="100">
        Tooltip content
      </TooltipPopoverWrapper>
    );

    expect(wrapper.find(PopperContent).props().offset).toEqual('100');
    wrapper.unmount();
  });

  it('should pass down flip', () => {
    const wrapper = mount(
      <TooltipPopoverWrapper isOpen target="target" flip={false}>
        Tooltip Content
      </TooltipPopoverWrapper>
    );

    expect(wrapper.find(PopperContent).props().flip).toBe(false);
    wrapper.unmount();
  });

  it('should not call props.toggle when disabled ', () => {
    const props = createSpyObj('props', ['toggle']);
    const event = createSpyObj('event', ['preventDefault']);

    const wrapper = mount(
      <TooltipPopoverWrapper target="target" disabled isOpen={isOpen} toggle={props.toggle}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    instance.toggle(event);

    expect(event.preventDefault).toHaveBeenCalled();
    expect(props.toggle).not.toHaveBeenCalled();

    wrapper.detach();
  });

  it('should not throw when props.toggle is not provided ', () => {
    const event = createSpyObj('event', ['preventDefault']);

    const wrapper = mount(
      <TooltipPopoverWrapper target="target" isOpen={isOpen}>
        Tooltip Content
      </TooltipPopoverWrapper>,
      { attachTo: container }
    );
    const instance = wrapper.instance();

    instance.toggle(event);

    wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
  });

  it('should not throw when passed a ref object as the target', () => {
    const targetObj = React.createRef();
<<<<<<< HEAD

    targetObj.current = {
      addEventListener: jest.fn(),
      removeEventListener: jest.fn(),
    };

    const { unmount } = render(
      <TooltipPopoverWrapper isOpen={false} target={targetObj}>
        Yo!
      </TooltipPopoverWrapper>,
    );

    unmount();
=======
    targetObj.current = createSpyObj('div', ['addEventListener', 'removeEventListener']);
    const event = createSpyObj('event', ['preventDefault']);
    const wrapper = mount(
      <TooltipPopoverWrapper target={targetObj}>Yo!</TooltipPopoverWrapper>,
      { attachTo: container });

    const instance = wrapper.instance();
    instance.toggle(event);

    wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254

    expect(targetObj.current.addEventListener).toHaveBeenCalled();
    expect(targetObj.current.removeEventListener).toHaveBeenCalled();
  });

  describe('multi target', () => {
<<<<<<< HEAD
    let targets;
    let targetContainer;
    beforeEach(() => {
      targetContainer = document.createElement('div');
      targetContainer.innerHTML =
        "<span class='example first'>Target 1</span><span class='example second'>Target 2<span class='inner_example'>Inner target</span></span>";
      element.appendChild(targetContainer);
      targets = targetContainer.querySelectorAll('.example');
=======
    let targets, innerTarget, targetContainer;
    beforeEach(() => {
      targetContainer = document.createElement('div');
      targetContainer.innerHTML = `<span class='example first'>Target 1</span><span class='example second'>Target 2<span class='inner_example'>Inner target</span></span>`
      element.appendChild(targetContainer);
      targets = targetContainer.querySelectorAll('.example');
      innerTarget = targetContainer.querySelector('.inner_example');
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });

    afterEach(() => {
      element.removeChild(targetContainer);
      targets = null;
<<<<<<< HEAD
    });

    it('should attach tooltip on multiple target when a target selector matches multiple elements', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target=".example"
          isOpen={false}
          toggle={toggle}
          delay={0}
        >
          Yo!
        </TooltipPopoverWrapper>,
      );

      user.click(targets[0]);
      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalledTimes(1);

      user.click(targets[1]);
      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalledTimes(2);
    });

    it('should attach tooltip on second target with correct placement, when inner element is clicked', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target=".example"
          isOpen={false}
          toggle={toggle}
          delay={0}
        >
          Yo!
        </TooltipPopoverWrapper>,
      );

      user.click(targets[0]);
      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalledTimes(1);
=======
      innerTarget = null;
    });

    it("should attach tooltip on multiple target when a target selector matches multiple elements", () => {
      const wrapper = mount(
        <TooltipPopoverWrapper target=".example" isOpen={isOpen} toggle={toggle} delay={0}>Yo!</TooltipPopoverWrapper>,
        { attachTo: container });

      targets[0].dispatchEvent(new Event('click'));
      jest.runTimersToTime(0)
      expect(isOpen).toBe(true);

      targets[0].dispatchEvent(new Event('click'));
      jest.runTimersToTime(0)
      expect(isOpen).toBe(false);

      targets[1].dispatchEvent(new Event('click'));
      jest.runTimersToTime(0)
      expect(isOpen).toBe(true);

      targets[1].dispatchEvent(new Event('click'));
      jest.runTimersToTime(0)
      expect(isOpen).toBe(false);
      wrapper.detach();
    });

    it("should attach tooltip on second target with correct placement, when inner element is clicked", () => {
      const wrapper = mount(
        <TooltipPopoverWrapper target=".example" isOpen={isOpen} toggle={toggle} delay={0}>Yo!</TooltipPopoverWrapper>,
        { attachTo: container });

      innerTarget.dispatchEvent(new Event('click'));
      jest.runTimersToTime(0)
      expect(isOpen).toBe(true);
      wrapper.setProps({ isOpen: true });
      expect(wrapper.find(PopperContent).props().target.className).toBe('example second');
      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('delay', () => {
    it('should accept a number', () => {
<<<<<<< HEAD
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={200}
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));

      jest.advanceTimersByTime(100);
      expect(toggle).not.toBeCalled();
      jest.advanceTimersByTime(100);
      expect(toggle).toBeCalled();
    });

    it('should accept an object', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={{ show: 400, hide: 400 }}
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));

      jest.advanceTimersByTime(200);
      expect(toggle).not.toBeCalled();
      jest.advanceTimersByTime(200);
      expect(toggle).toBeCalled();
    });

    it('should use default value if value is missing from object', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={{ show: 0 }}
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));

      jest.advanceTimersByTime(10);
      expect(toggle).not.toBeCalled();
      jest.advanceTimersByTime(40); // default hide value is 50
      expect(toggle).toBeCalled();
=======
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} delay={200}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.hideWithDelay();
      expect(isOpen).toBe(true);
      jest.runTimersToTime(200);
      expect(isOpen).toBe(false);
    });

    it('should accept an object', () => {
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} delay={{ show: 200, hide: 200 }}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.hideWithDelay();
      expect(isOpen).toBe(true);
      jest.runTimersToTime(200);
      expect(isOpen).toBe(false);
    });

    it('should use default value if value is missing from object', () => {
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} delay={{ show: 0 }}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.hideWithDelay();
      expect(isOpen).toBe(true);
      jest.runTimersToTime(250); // Default hide value: 250
      expect(isOpen).toBe(false);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('hide', () => {
    it('should call toggle when isOpen', () => {
<<<<<<< HEAD
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper target="target" isOpen toggle={toggle}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));

      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalled();
=======
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(spy).not.toHaveBeenCalled();

      instance.hide();

      expect(spy).toHaveBeenCalled();

      wrapper.detach();
    });

    it('should not call toggle when isOpen is false', () => {
      const spy = jest.fn(toggle);
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(spy).not.toHaveBeenCalled();

      instance.hide();

      expect(spy).not.toHaveBeenCalled();

      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('show', () => {
<<<<<<< HEAD
    it('should call toggle when isOpen', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper target="target" isOpen={false} toggle={toggle}>
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.click(screen.getByText(/target/i));

      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalled();
    });
  });

  describe('onMouseOverTooltip', () => {
    it('should clear timeout if it exists on target click', () => {
      const toggle = jest.fn();
      const { rerender } = render(
        <TooltipPopoverWrapper
          target="target"
          isOpen={false}
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.hover(screen.getByText(/target/i));

      rerender(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.unhover(screen.getByText(/target/i));

      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should not call .toggle if isOpen', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.hover(screen.getByText(/target/i));
      jest.advanceTimersByTime(200);
      expect(toggle).not.toHaveBeenCalled();
=======
    it('should call toggle when isOpen is false', () => {
      const spy = jest.fn(toggle);
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(spy).not.toHaveBeenCalled();

      instance.show();

      expect(spy).toHaveBeenCalled();

      wrapper.detach();
    });

    it('should not call toggle when isOpen', () => {
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(spy).not.toHaveBeenCalled();

      instance.show();

      expect(spy).not.toHaveBeenCalled();

      wrapper.detach();
    });
  });

  describe('onMouseOverTooltip', () => {
    it('should clear timeout if it exists on target click', () => {
      const spy = jest.fn(toggle);
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy} delay={200} trigger="manual">
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.hideWithDelay();

      expect(isOpen).toBe(false);
      expect(spy).not.toHaveBeenCalled();

      instance.showWithDelay();
      jest.runTimersToTime(200);

      expect(spy).toHaveBeenCalled();

      wrapper.detach();
    });

    it('should not call .toggle if isOpen', () => {
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy} delay={0}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.showWithDelay();
      jest.runTimersToTime(0); // delay: 0 toggle is still async

      expect(isOpen).toBe(true);
      expect(spy).not.toHaveBeenCalled();

      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('onMouseLeaveTooltip', () => {
    it('should clear timeout if it exists on target click', () => {
<<<<<<< HEAD
      const toggle = jest.fn();
      const { rerender } = render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.unhover(screen.getByText(/target/i));

      rerender(
        <TooltipPopoverWrapper
          target="target"
          isOpen={false}
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.hover(screen.getByText(/target/i));

      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should not call .toggle if isOpen is false', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen={false}
          toggle={toggle}
          delay={200}
          trigger="hover"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.unhover(screen.getByText(/target/i));
      jest.advanceTimersByTime(200);
      expect(toggle).not.toHaveBeenCalled();
=======
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy} delay={200}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.showWithDelay();

      expect(isOpen).toBe(true);
      expect(spy).not.toHaveBeenCalled();

      instance.hideWithDelay();
      jest.runTimersToTime(200);

      expect(spy).toHaveBeenCalled();

      wrapper.detach();
    });

    it('should not call .toggle if isOpen is false', () => {
      const spy = jest.fn(toggle);
      isOpen = false;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={spy} delay={0}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.hideWithDelay();
      jest.runTimersToTime(0); // delay: 0 toggle is still async

      expect(isOpen).toBe(false);
      expect(spy).not.toHaveBeenCalled();

      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('autohide', () => {
    it('should keep Tooltip around when false and onmouseleave from Tooltip content', () => {
<<<<<<< HEAD
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          trigger="hover"
          target="target"
          autohide={false}
          isOpen
          toggle={toggle}
          delay={200}
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.hover(screen.getByText(/tooltip content/i));
      jest.advanceTimersByTime(200);
      expect(toggle).not.toHaveBeenCalled();
      user.unhover(screen.getByText(/tooltip content/i));
      jest.advanceTimersByTime(200);
      expect(toggle).toHaveBeenCalled();
    });

    it('clears showTimeout and hideTimeout in onMouseLeaveTooltipContent', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          trigger="hover"
          target="target"
          autohide={false}
          isOpen
          toggle={toggle}
          delay={200}
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.unhover(screen.getByText(/tooltip content/i));
      user.hover(screen.getByText(/tooltip content/i));
      user.unhover(screen.getByText(/tooltip content/i));

      jest.advanceTimersByTime(200);

      expect(toggle).toBeCalledTimes(1);
    });

    it('should not keep Tooltip around when autohide is true and Tooltip content is hovered over', () => {
      const toggle = jest.fn();
      render(
        <TooltipPopoverWrapper
          target="target"
          autohide
          isOpen
          toggle={toggle}
          delay={200}
          trigger="click hover focus"
        >
          Tooltip Content
        </TooltipPopoverWrapper>,
      );

      user.unhover(screen.getByText(/target/i));
      user.hover(screen.getByText(/tooltip content/i));

      jest.advanceTimersByTime(200);

      expect(toggle).toHaveBeenCalled();
=======
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper trigger="hover" target="target" autohide={false} isOpen={isOpen} toggle={spy} delay={200}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(isOpen).toBe(true);
      expect(spy).not.toHaveBeenCalled();

      instance.onMouseLeaveTooltipContent(synthEvent);
      jest.runTimersToTime(100);
      expect(spy).not.toHaveBeenCalled();
      jest.runTimersToTime(200);
      expect(spy).toHaveBeenCalled();

      wrapper.detach();
    });

    it('clears showTimeout in onMouseLeaveTooltipContent', () => {
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper trigger="hover" target="target" autohide={false} isOpen={isOpen} toggle={spy} delay={200}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      instance.showWithDelay();
      expect(instance._showTimeout).toBeTruthy();
      instance.onMouseLeaveTooltipContent(synthEvent);
      jest.runTimersToTime(300);
      expect(instance._showTimeout).toBeFalsy();
      wrapper.detach();
    });

    it('clears hide timeout in onMouseOverTooltipContent', () => {
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper trigger="hover" target="target" autohide={false} isOpen={isOpen} toggle={spy} delay={200}>
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();

      expect(isOpen).toBe(true);
      expect(spy).not.toHaveBeenCalled();
      instance.onMouseLeaveTooltipContent(synthEvent);
      jest.runTimersToTime(100);
      expect(instance._hideTimeout).toBeTruthy();
      instance.onMouseOverTooltipContent();
      expect(instance._hideTimeout).toBeFalsy();
      instance.onMouseOverTooltipContent();
      wrapper.detach();
    });

    it('should not keep Tooltip around when autohide is true and Tooltip content is hovered over', () => {
      const spy = jest.fn(toggle);
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" autohide isOpen={isOpen} toggle={spy} delay={200} trigger="click hover focus">
          Tooltip Content
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );
      const instance = wrapper.instance();
      expect(isOpen).toBe(true);
      expect(spy).not.toHaveBeenCalled();
      instance.hideWithDelay();
      jest.runTimersToTime(100);
      instance.onMouseOverTooltipContent();
      jest.runTimersToTime(200);
      expect(spy).toHaveBeenCalled();
      instance.onMouseLeaveTooltipContent(synthEvent);
      expect(instance._hideTimeout).toBeFalsy();
      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });

    it('should allow a function to be used as children', () => {
      const renderChildren = jest.fn();
<<<<<<< HEAD
      render(
        <TooltipPopoverWrapper target="target" isOpen>
          {renderChildren}
        </TooltipPopoverWrapper>,
=======
      mount(
        <TooltipPopoverWrapper target="target" isOpen toggle={toggle}>
          {renderChildren}
        </TooltipPopoverWrapper>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
      );
      expect(renderChildren).toHaveBeenCalled();
    });

    it('should render children properly when children is a function', () => {
<<<<<<< HEAD
      render(
        <TooltipPopoverWrapper
          target="target"
          isOpen
          className="tooltip show"
          trigger="hover"
        >
          {() => 'Tooltip Content'}
        </TooltipPopoverWrapper>,
      );

      expect(screen.getByText(/tooltip content/i)).toBeInTheDocument();
=======
      isOpen = true;
      const wrapper = mount(
        <TooltipPopoverWrapper target="target" isOpen={isOpen} toggle={toggle} className="tooltip show" trigger="hover">
          {() => 'Tooltip Content'}
        </TooltipPopoverWrapper>,
        { attachTo: container }
      );

      const Tooltips = document.getElementsByClassName('tooltip');
      expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
      expect(Tooltips.length).toBe(1);
      expect(Tooltips[0].textContent).toBe('Tooltip Content');

      expect(wrapper.find('.tooltip.show').hostNodes().length).toBe(1);
      expect(Tooltips.length).toBe(1);
      expect(Tooltips[0].textContent).toBe('Tooltip Content');

      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });
});
