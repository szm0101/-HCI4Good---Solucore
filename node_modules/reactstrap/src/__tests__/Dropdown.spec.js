import React from 'react';
import { mount, shallow } from 'enzyme';
import { Popper, Reference } from 'react-popper';
<<<<<<< HEAD
import { createEvent, fireEvent, render, screen } from '@testing-library/react';
import user from '@testing-library/user-event';
import '@testing-library/jest-dom';
import { Dropdown, DropdownToggle, DropdownMenu, DropdownItem } from '..';
import { keyCodes } from '../utils';
import { testForChildrenInComponent } from '../testUtils';

describe('Dropdown', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.restoreAllMocks();
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
  });

  function imitateDropdownFocus(toggle) {
    // this is needed to make the focus on the correct element
    // by following the default user behaviour
    // needed in particular for keyboard based tests
    // setting focus on the toggle element with code
    // is causing tab to cycle through elements.
    const { rerender } = render(
      <Dropdown isOpen={false} toggle={toggle} data-testid="drpdwn">
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>First item</DropdownItem>
          <DropdownItem>Second item</DropdownItem>
          <DropdownItem id="divider" divider />
        </DropdownMenu>
      </Dropdown>,
    );

    user.click(screen.getByText('Toggle'));
    toggle.mockClear();

    rerender(
      <Dropdown isOpen toggle={toggle} data-testid="drpdwn">
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>First item</DropdownItem>
          <DropdownItem>Second item</DropdownItem>
          <DropdownItem id="divider" divider />
        </DropdownMenu>
      </Dropdown>,
    );

    return { rerender };
  }

  it('should render a single child', () => {
    render(<Dropdown isOpen>Ello world</Dropdown>);

    expect(screen.getByText(/ello world/i)).toHaveClass('dropdown');
  });

  it('should render menu when isOpen is true', () => {
    render(
      <Dropdown isOpen>
=======
import { Dropdown, DropdownToggle, DropdownMenu, DropdownItem } from '../';
import { keyCodes } from '../utils';

describe('Dropdown', () => {
  let isOpen;
  let toggle;
  let element;

  beforeEach(() => {
    isOpen = false;
    toggle = () => { isOpen = !isOpen; };
    element = document.createElement('div');
    document.body.appendChild(element);
  });

  afterEach(() => {
    if (jest.isMockFunction(Dropdown.prototype.componentDidUpdate)) Dropdown.prototype.componentDidUpdate.mockRestore();
    if (jest.isMockFunction(Dropdown.prototype.handleProps)) Dropdown.prototype.handleProps.mockRestore();
    if (jest.isMockFunction(Dropdown.prototype.toggle)) Dropdown.prototype.toggle.mockRestore();
    if (jest.isMockFunction(Dropdown.prototype.handleDocumentClick)) Dropdown.prototype.handleDocumentClick.mockRestore();
    document.body.removeChild(element);
    document.body.innerHTML = '';
    element = null;
  });

  it('should render a single child', () => {
    const wrapper = mount(<Dropdown isOpen={isOpen} toggle={toggle}>Ello world</Dropdown>);

    expect(wrapper.text()).toBe('Ello world');
    expect(wrapper.find('.dropdown').hostNodes().length).toBe(1);
  });

  it('should render multiple children when isOpen is true', () => {
    isOpen = true;
    const wrapper = mount(
      <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
<<<<<<< HEAD
      </Dropdown>,
    );

    expect(screen.getByText(/toggle/i)).toHaveClass('btn');
    expect(screen.getByText(/test/i)).toHaveClass('dropdown-item');
  });

  it('should not call props.toggle when disabled ', () => {
    const toggle = jest.fn();
    render(
      <Dropdown isOpen toggle={toggle} disabled>
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
      </Dropdown>,
    );

    user.click(screen.getByText(/toggle/i));
    expect(toggle).not.toHaveBeenCalled();
  });

  it('should call toggle when DropdownToggle is clicked ', () => {
    const toggle = jest.fn();
    render(
      <Dropdown isOpen toggle={toggle}>
=======
      </Dropdown>
    );

    expect(wrapper.find('.btn').hostNodes().text()).toBe('Toggle');
    expect(wrapper.find('.dropdown').hostNodes().length).toBe(1);
    expect(wrapper.find('.dropdown-item').hostNodes().length).toBe(1);
    expect(wrapper.childAt(0).childAt(0).children().length).toBe(2);
  });

  it('should not call props.toggle when disabled ', () => {
    isOpen = true;
    let props = createSpyObj('props', ['toggle']);
    const wrapper = mount(
      <Dropdown isOpen={isOpen} toggle={props.toggle} disabled>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
<<<<<<< HEAD
      </Dropdown>,
    );

    user.click(screen.getByText(/toggle/i));
    expect(toggle).toHaveBeenCalledTimes(1);
  });

  it('should call toggle when DropdownToggle with non string children is clicked ', () => {
    const toggle = jest.fn();
    render(
      <Dropdown isOpen toggle={toggle}>
        <DropdownToggle>
          <div>Toggle</div>
        </DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
      </Dropdown>,
    );

    user.click(screen.getByText(/toggle/i));
    expect(toggle).toHaveBeenCalledTimes(1);
=======
      </Dropdown>
    );
    const instance = wrapper.instance();

    instance.toggle({ preventDefault: () => { } });
    expect(props.toggle).not.toHaveBeenCalled();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
  });

  describe('handleProps', () => {
    it('should not pass custom props to html attrs', () => {
<<<<<<< HEAD
      const toggle = jest.fn();
      render(
        <Dropdown a11y isOpen toggle={toggle}>
=======
      const wrapper = mount(
        <Dropdown inNavbar a11y isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      const dropdown = document.getElementsByClassName('dropdown')[0];
      expect(dropdown).not.toHaveAttribute('inNavbar');
      expect(dropdown).not.toHaveAttribute('toggle');
      expect(dropdown).not.toHaveAttribute('a11y');
      expect(dropdown).not.toHaveAttribute('isOpen');
    });

    it('should add event listeners when isOpen changed to true', () => {
      const addEventListener = jest.spyOn(document, 'addEventListener');
      const { rerender } = render(
        <Dropdown isOpen={false}>
=======
        </Dropdown>
      );

      expect(wrapper.find('.dropdown').prop('inNavbar')).toBe(undefined);
      expect(wrapper.find('.dropdown').prop('toggle')).toBe(undefined);
      expect(wrapper.find('.dropdown').prop('a11y')).toBe(undefined);
      expect(wrapper.find('.dropdown').prop('isOpen')).toBe(undefined);
    });

    it('should be called on componentDidUpdate when isOpen changed', () => {
      jest.spyOn(Dropdown.prototype, 'componentDidUpdate');
      jest.spyOn(Dropdown.prototype, 'handleProps');
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      expect(addEventListener).not.toHaveBeenCalled();

      rerender(
        <Dropdown isOpen>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      // called three times because we have click, touchstart and keyup
      expect(addEventListener).toHaveBeenCalledTimes(3);
    });

    it('should not be called on componentDidUpdate when isOpen did not change', () => {
      const addEventListener = jest.spyOn(document, 'addEventListener');
      const { rerender } = render(
        <Dropdown isOpen>
=======
        </Dropdown>
      );

      const instance = wrapper.instance();

      expect(Dropdown.prototype.componentDidUpdate.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.handleProps.mock.calls.length).toBe(1);
      expect(instance.props.isOpen).toBe(false);

      isOpen = true;
      wrapper.setProps({ isOpen: isOpen });

      expect(Dropdown.prototype.componentDidUpdate.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.handleProps.mock.calls.length).toBe(2);
      expect(instance.props.isOpen).toBe(true);
    });

    it('should not be called on componentDidUpdate when isOpen did not change', () => {
      jest.spyOn(Dropdown.prototype, 'componentDidUpdate');
      jest.spyOn(Dropdown.prototype, 'handleProps');
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      expect(addEventListener).toHaveBeenCalled();
      addEventListener.mockClear();

      rerender(
        <Dropdown isOpen size="lg">
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      expect(addEventListener).not.toHaveBeenCalled();
=======
        </Dropdown>
      );
      const instance = wrapper.instance();

      expect(Dropdown.prototype.componentDidUpdate.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.handleProps.mock.calls.length).toBe(1);
      expect(instance.props.isOpen).toBe(false);

      wrapper.setProps({ 'data-foo': 'bar' });

      expect(Dropdown.prototype.componentDidUpdate.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.handleProps.mock.calls.length).toBe(1);
      expect(instance.props.isOpen).toBe(false);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('removeEvents', () => {
<<<<<<< HEAD
    it('should remove event listeners on componentWillUnmount', () => {
      const removeEventListener = jest.spyOn(document, 'removeEventListener');
      const { unmount } = render(
        <Dropdown isOpen>
=======
    it('should be called on componentWillUnmount', () => {
      jest.spyOn(Dropdown.prototype, 'componentWillUnmount');
      jest.spyOn(Dropdown.prototype, 'removeEvents');
      isOpen = true;
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      unmount();

      expect(removeEventListener).toHaveBeenCalled();
=======
        </Dropdown>
      );

      expect(Dropdown.prototype.componentWillUnmount.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.removeEvents.mock.calls.length).toBe(0);

      wrapper.unmount();

      expect(Dropdown.prototype.componentWillUnmount.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.removeEvents.mock.calls.length).toBe(1);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('handleDocumentClick', () => {
    it('should call toggle on document click', () => {
<<<<<<< HEAD
      const toggle = jest.fn(() => {});

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.click(document.body);

      expect(toggle).toHaveBeenCalled();
    });

    it('should call toggle on container click', () => {
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle} data-testid="dropdown">
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.click(screen.getByTestId('dropdown'));

      expect(toggle).toHaveBeenCalled();
    });

    it('should call toggle on container click', () => {
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle} data-testid="dropdown">
          <DropdownToggle>
            <div>Toggle</div>
          </DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.click(screen.getByTestId('dropdown'));

      expect(toggle).toHaveBeenCalled();
    });

    it('should not call toggle on inner container click', () => {
      const toggle = jest.fn();
      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      user.click(document.getElementById('divider'));

      expect(toggle).not.toHaveBeenCalled();
    });

    it('should not call toggle when right-clicked', () => {
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle} data-testid="dropdown">
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      user.click(screen.getByTestId('dropdown'), { button: 2 });

      expect(toggle).not.toHaveBeenCalled();
    });

    it('should go through first dropdown item and close when tab is pressed multiple times', async () => {
      const toggle = jest.fn();

      imitateDropdownFocus(toggle);

      user.tab();
      expect(screen.getByText(/first item/i)).toHaveFocus();

      user.tab();
      expect(toggle).toHaveBeenCalledTimes(1);
=======
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'handleDocumentClick');
      jest.spyOn(Dropdown.prototype, 'toggle');

      mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      document.body.click();

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);
    });

    it('should call toggle on container click', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'handleDocumentClick');
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown id="test" isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      document.getElementById('test').click();

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should not call toggle on inner container click', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'handleDocumentClick');
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      document.getElementById('divider').click();

      expect(Dropdown.prototype.handleDocumentClick.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should not call toggle when right-clicked', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.instance().handleDocumentClick({ type: 'click', which: 3 });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      wrapper.detach();
    });

    it('should call toggle when key is tab', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.instance().handleDocumentClick({ type: 'keyup', which: keyCodes.tab });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);
      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('keyboard events', () => {
    it('should call toggle on ESC keydown when it isOpen is true', () => {
<<<<<<< HEAD
      const toggle = jest.fn();

      imitateDropdownFocus(toggle);

      user.keyboard('{esc}');

      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should call toggle on down arrow keydown when it isOpen is false', () => {
      const toggle = jest.fn();
      render(
        <Dropdown isOpen={false} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();

      user.keyboard('{arrowdown}');
      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should call toggle on up arrow keydown when it isOpen is false', () => {
      const toggle = jest.fn();
      render(
        <Dropdown isOpen={false} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();

      user.keyboard('{arrowup}');
      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should focus the first menuitem when toggle is triggered by enter keydown', () => {
      const toggle = jest.fn();
      const focus = jest.fn();
      render(
        <Dropdown isOpen={false} toggle={toggle}>
=======
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="test">Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#test').hostNodes().simulate('keydown', { which: keyCodes.esc });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should call toggle on down arrow keydown when it isOpen is false', () => {
      isOpen = false;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', { which: keyCodes.down });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should call toggle on up arrow keydown when it isOpen is false', () => {
      isOpen = false;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', { which: keyCodes.up });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the first menuitem when toggle is triggered by enter keydown', () => {
      jest.useFakeTimers();
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus = jest.fn();
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem header>Header</DropdownItem>
            <DropdownItem disabled>Disabled</DropdownItem>
            <DropdownItem onFocus={focus}>Test</DropdownItem>
            <DropdownItem divider />
            <DropdownItem>Another Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();

      expect(focus).not.toHaveBeenCalled();

      user.keyboard('{enter}');
      expect(toggle).toHaveBeenCalled();

      jest.runAllTimers();
      expect(focus).toHaveBeenCalled();
    });

    it('should focus the first menuitem when toggle is triggered by up arrow keydown', () => {
      const toggle = jest.fn();
      const focus = jest.fn();
      render(
        <Dropdown isOpen={false} toggle={toggle}>
=======
        </Dropdown>, { attachTo: element }
      );

      expect(focus.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', { which: keyCodes.enter });
      jest.runAllTimers();

      expect(focus.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the first menuitem when toggle is triggered by up arrow keydown', () => {
      jest.useFakeTimers();
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus = jest.fn();
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem header>Header</DropdownItem>
            <DropdownItem disabled>Disabled</DropdownItem>
            <DropdownItem onFocus={focus}>Test</DropdownItem>
            <DropdownItem divider />
            <DropdownItem>Another Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();

      expect(focus).not.toHaveBeenCalled();

      user.keyboard('{arrowdown}');
      expect(toggle).toHaveBeenCalled();

      jest.runAllTimers();
      expect(focus).toHaveBeenCalled();
    });

    it('should focus the first menuitem when toggle is triggered by down arrow keydown', () => {
      const toggle = jest.fn();
      const focus = jest.fn();
      render(
        <Dropdown isOpen={false} toggle={toggle}>
=======
        </Dropdown>, { attachTo: element }
      );

      expect(focus.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', { which: keyCodes.up });
      jest.runAllTimers();

      expect(focus.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the first menuitem when toggle is triggered by down arrow keydown', () => {
      jest.useFakeTimers();
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus = jest.fn();
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem header>Header</DropdownItem>
            <DropdownItem disabled>Disabled</DropdownItem>
            <DropdownItem onFocus={focus}>Test</DropdownItem>
            <DropdownItem divider />
            <DropdownItem>Another Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();

      expect(focus).not.toHaveBeenCalled();

      user.keyboard('{arrowup}');
      expect(toggle).toHaveBeenCalled();

      jest.runAllTimers();
      expect(focus).toHaveBeenCalled();
      expect(screen.getByText('Test')).toHaveFocus();
    });

    it('should focus the next menuitem on down arrow keydown when isOpen is true', () => {
      const toggle = jest.fn();
      const focus = jest.fn();
      const focus2 = jest.fn();
      const { rerender } = render(
        <Dropdown isOpen={false} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem header>Header</DropdownItem>
            <DropdownItem disabled>Disabled</DropdownItem>
            <DropdownItem onFocus={focus}>Test</DropdownItem>
            <DropdownItem>i am focused</DropdownItem>
            <DropdownItem divider />
            <DropdownItem>Another Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      expect(screen.getByText('Toggle')).toHaveFocus();
      expect(focus).not.toHaveBeenCalled();

      user.keyboard('{arrowup}');
      expect(toggle).toHaveBeenCalled();

      rerender(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem header>Header</DropdownItem>
            <DropdownItem disabled>Disabled</DropdownItem>
            <DropdownItem onFocus={focus}>Test</DropdownItem>
            <DropdownItem onFocus={focus2}>i am focused</DropdownItem>
            <DropdownItem divider />
            <DropdownItem>Another Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      jest.runAllTimers();
      expect(focus).toHaveBeenCalled();
      expect(screen.getByText('Test')).toHaveFocus();

      user.keyboard('{arrowdown}');
      expect(focus2).toHaveBeenCalled();
      expect(screen.getByText('i am focused')).toHaveFocus();
    });

    it('should focus the next menuitem on ctrl + n keydown when isOpen is true', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      screen.getByText('Test1').focus();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{ctrl>}N');
      expect(screen.getByText('Test2')).toHaveFocus();
    });

    it('should focus the first menu item matching the character pressed when isOpen is true', () => {
=======
        </Dropdown>, { attachTo: element }
      );

      expect(focus.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', { which: keyCodes.down });
      jest.runAllTimers();

      expect(focus.mock.calls.length).toBe(1);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the next menuitem on down arrow keydown when isOpen is true', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.down });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(1);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should focus the next menuitem on ctrl + n keydown when isOpen is true', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.n, ctrlKey: true });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(1);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should focus the first menu item matching the character pressed when isOpen is true', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
>>>>>>> babce7e82dc134320378dfce834b316b88320254
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

<<<<<<< HEAD
      render(
        <Dropdown isOpen>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Reactstrap
            </DropdownItem>
=======
      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Reactstrap</DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem onFocus={focus2}>4</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}> Lyfe</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Reactstrap')).toHaveFocus();

      focus1.mockClear();

      user.keyboard('4');
      expect(screen.getByText('4')).toHaveFocus();
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: 52 });
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
>>>>>>> babce7e82dc134320378dfce834b316b88320254

      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(1);
      expect(focus3.mock.calls.length).toBe(0);
<<<<<<< HEAD
    });

    it('should skip non-menu items focus the next menu item on down arrow keydown when it isOpen is true and anther item is focused', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowdown}');
      expect(screen.getByText('Test2')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
    });

    it('should focus the previous menu item on up arrow keydown when isOpen is true and another item is focused', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowdown}');
      expect(screen.getByText('Test2')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
      user.keyboard('{arrowup}');
      expect(screen.getByText('Test1')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(2);
    });

    it('should focus the previous menuitem on ctrl + p keydown when isOpen is true and another item is focused', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      screen.getByText('Test1').focus();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowdown}');
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
      expect(screen.getByText('Test2')).toHaveFocus();
      user.keyboard('{ctrl>}P');
      expect(screen.getByText('Test1')).toHaveFocus();
    });

    it('should wrap focus with down arrow keydown', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowdown}');
      expect(screen.getByText('Test2')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
      user.keyboard('{arrowdown}');
      expect(screen.getByText('Test1')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(2);
    });

    it('should wrap focus with up arrow keydown', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowup}');
      expect(screen.getByText('Test2')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
    });

    it('should focus the 1st item on home key keyDown', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
            <DropdownItem onFocus={focus3}>Test3</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{arrowdown}');
      user.keyboard('{arrowdown}');
      expect(screen.getByText('Test3')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(1);
      expect(focus3).toBeCalledTimes(1);
      user.keyboard('{home}');
      expect(screen.getByText('Test1')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(2);
    });

    it('should focus the last item on end key keyDown', () => {
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem id="first" onFocus={focus1}>
              Test1
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus2}>Test2</DropdownItem>
            <DropdownItem onFocus={focus3}>Test3</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();
      user.keyboard('{end}');
      expect(screen.getByText('Test3')).toHaveFocus();
      expect(toggle).not.toHaveBeenCalled();
      expect(focus1).toBeCalledTimes(1);
      expect(focus2).toBeCalledTimes(0);
      expect(focus3).toBeCalledTimes(1);
    });

    it('should trigger a click on links when an item is focused and space[bar] it pressed', () => {
      const click = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu end>
            <DropdownItem href="#" id="first" onClick={click}>
              Test1
            </DropdownItem>
=======

      wrapper.detach();
    });

    it('should skip non-menu items focus the next menu item on down arrow keydown when it isOpen is true and anther item is focused', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#second').hostNodes().simulate('keydown', { which: keyCodes.down });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the previous menu item on up arrow keydown when isOpen is true and another item is focused', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#second').hostNodes().simulate('keydown', { which: keyCodes.up });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(1);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should focus the previous menuitem on ctrl + p keydown when isOpen is true and another item is focused', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#second').hostNodes().simulate('keydown', { which: keyCodes.p, ctrlKey: true });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(1);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should wrap focus with down arrow keydown', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third" onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#third').hostNodes().simulate('keydown', { which: keyCodes.down });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(1);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should wrap focus with up arrow keydown', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third" onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.up });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should focus the 1st item on home key keyDown', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="zero" disabled>Test</DropdownItem>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third" onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.home });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(1);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should focus the last item on end key keyDown', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus1 = jest.fn();
      const focus2 = jest.fn();
      const focus3 = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="zero" disabled>Test</DropdownItem>
            <DropdownItem id="first" onFocus={focus1}>Test</DropdownItem>
            <DropdownItem id="second" onFocus={focus2}>Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third" onFocus={focus3}>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.end });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(focus1.mock.calls.length).toBe(0);
      expect(focus2.mock.calls.length).toBe(0);
      expect(focus3.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should trigger a click on links when an item is focused and space[bar] it pressed', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem href="#" id="first" onClick={click}>Test</DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third">Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      user.tab();
      user.tab();
      expect(screen.getByText('Test1')).toHaveFocus();

      user.keyboard('{space}');

      expect(click).toHaveBeenCalled();
    });

    it('should trigger a click on buttons when an item is focused and space[bar] it pressed (override browser defaults for focus management)', () => {
      const toggle = jest.fn();
      const click = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="first" onClick={click}>
              Test1
            </DropdownItem>
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);
      expect(click.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should trigger a click on buttons when an item is focused and space[bar] it pressed (override browser defaults for focus management)', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem id="first" onClick={click}>Test</DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third">Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      screen.getByText('Test1').focus();
      expect(toggle).not.toHaveBeenCalled();
      expect(screen.getByText('Test1')).toHaveFocus();

      user.keyboard('{space}');

      expect(toggle).toHaveBeenCalledTimes(1);
      expect(click).toHaveBeenCalledTimes(1);
    });

    it('should not trigger anything when within an input', () => {
      const click = jest.fn();
      const focus = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}>
              <input id="input" placeholder="name" />
            </DropdownItem>
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);
      expect(click.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should not trigger anything when within an input', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();
      const focus = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}><input id="input" /></DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third">Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );
      screen.getByPlaceholderText('name').focus();
      expect(screen.getByPlaceholderText(/name/i)).toHaveFocus();

      focus.mockClear();
      click.mockClear();

      user.keyboard('{arrowdown}');
      user.keyboard('{arrowup}');
      user.keyboard('{space}');

      expect(toggle).not.toHaveBeenCalled();

      expect(screen.getByPlaceholderText(/name/i)).toHaveFocus();

      expect(focus).not.toHaveBeenCalled();
      expect(click).not.toHaveBeenCalled();
    });

    it('should not trigger anything when within a textarea', () => {
      const click = jest.fn();
      const focus = jest.fn();
      const toggle = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}>
              <textarea id="input" placeholder="placeholder" />
            </DropdownItem>
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.up });
      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.down });
      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(click.mock.calls.length).toBe(0);
      expect(focus.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should not trigger anything when within a textarea', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();
      const focus = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}><textarea id="input" /></DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third">Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      screen.getByPlaceholderText(/placeholder/i).focus();
      expect(screen.getByPlaceholderText(/placeholder/i)).toHaveFocus();

      focus.mockClear();
      click.mockClear();

      user.keyboard('{arrowdown}');
      user.keyboard('{arrowup}');
      user.keyboard('{space}');

      expect(toggle).not.toHaveBeenCalled();

      expect(screen.getByPlaceholderText(/placeholder/i)).toHaveFocus();

      expect(focus).not.toHaveBeenCalled();
      expect(click).not.toHaveBeenCalled();
    });

    it('should toggle when isOpen is true and tab keyDown on menuitem', () => {
      const toggle = jest.fn();
      const focus = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="first">First</DropdownItem>
            <DropdownItem id="second" onFocus={focus}>
              Second
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      screen.getByText(/first/i).focus();

      user.tab();

      expect(toggle).toHaveBeenCalledTimes(1);
    });

    it('should not trigger anything when disabled', () => {
      const toggle = jest.fn();
      const click = jest.fn();
      const focus = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle} disabled>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}>
              Test1
            </DropdownItem>
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.up });
      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.down });
      wrapper.find('#input').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(click.mock.calls.length).toBe(0);
      expect(focus.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should toggle when isOpen is true and tab keyDown on menuitem', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const focus = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem id="first">First</DropdownItem>
            <DropdownItem id="second" onFocus={focus}>Second</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
        { attachTo: element }
      );

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.tab });

      expect(focus.mock.calls.length).toBe(0);
      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(1);

      wrapper.detach();
    });

    it('should not trigger anything when disabled', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();
      const focus = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle} disabled>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem tag="div" id="first" onClick={click} onFocus={focus}>Test</DropdownItem>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
            <DropdownItem id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem id="third">Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      screen.getByText(/test1/i).focus();

      focus.mockClear();

      user.keyboard('{arrowdown}');
      user.keyboard('{arrowup}');
      user.keyboard('{space}');

      expect(toggle).not.toHaveBeenCalled();
      expect(click).not.toHaveBeenCalled();
      expect(focus).not.toHaveBeenCalled();
    });

    it('should not focus anything when all items disabled', () => {
      const toggle = jest.fn();
      const click = jest.fn();
      const focus = jest.fn();

      render(
        <Dropdown isOpen toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem
              disabled
              tag="div"
              id="first"
              onClick={click}
              onFocus={focus}
            >
              Test
            </DropdownItem>
            <DropdownItem disabled id="second">
              Test
            </DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem disabled id="third">
              Test
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      screen.getByText(/toggle/i).focus();

      user.keyboard('{arrowdown}');
      user.keyboard('{arrowup}');
      user.keyboard('{space}');

      expect(toggle).not.toHaveBeenCalled();
      expect(click).not.toHaveBeenCalled();
      expect(focus).not.toHaveBeenCalled();
    });

    it('should not call preventDefault when dropdown has focus and f5 key is pressed', () => {
      const toggle = jest.fn();

      render(
        <Dropdown isOpen={false} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      expect(toggle).not.toHaveBeenCalled();

      const button = screen.getByText(/toggle/i);

      const keyEvent1 = createEvent.keyDown(button, {
        keyCode: 116,
      });
      fireEvent(button, keyEvent1);
      expect(keyEvent1.defaultPrevented).toBe(false);

      const keyEvent2 = createEvent.keyDown(button, {
        keyCode: 16,
      });
      fireEvent(button, keyEvent2);
      expect(keyEvent2.defaultPrevented).toBe(false);
    });

    it('should call preventDefault when dropdown has focus and any key(up, down, esc, enter, home, end or any alphanumeric key) is pressed', () => {
      const toggle = jest.fn();

      render(
        <Dropdown isOpen={false} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>,
      );

      expect(toggle).not.toHaveBeenCalled();

      const button = screen.getByText(/toggle/i);
      [
        keyCodes.down,
        keyCodes.up,
        keyCodes.end,
        keyCodes.home,
        keyCodes.enter,
        90, // for 'a'
        65, // for 'A'
      ].forEach((keyCode) => {
        const keyEvent = createEvent.keyDown(button, {
          keyCode,
        });
        fireEvent(button, keyEvent);
        expect(keyEvent.defaultPrevented).toBe(true);
      });
=======
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.up });
      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.down });
      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(click.mock.calls.length).toBe(0);
      expect(focus.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should not focus anything when all items disabled', () => {
      isOpen = true;
      jest.spyOn(Dropdown.prototype, 'toggle');
      const click = jest.fn();
      const focus = jest.fn();

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem disabled tag="div" id="first" onClick={click} onFocus={focus}>Test</DropdownItem>
            <DropdownItem disabled id="second">Test</DropdownItem>
            <DropdownItem id="divider" divider />
            <DropdownItem disabled id="third">Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);

      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.up });
      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.down });
      wrapper.find('#first').hostNodes().simulate('keydown', { which: keyCodes.space });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      expect(click.mock.calls.length).toBe(0);
      expect(focus.mock.calls.length).toBe(0);

      wrapper.detach();
    });

    it('should not call preventDefault when dropdown has focus and f5 key is pressed', () => {
      isOpen = false;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      const event = { preventDefault: ()=>{} };
      const spy = jest.spyOn(event, 'preventDefault');

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: 116/*f5 key*/});
      expect(spy).not.toHaveBeenCalled(); 
      
      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: 16/*shift key*/});
      expect(spy).not.toHaveBeenCalled();  

      wrapper.detach();
    });

    it('should call preventDefault when dropdown has focus and any key(up, down, esc, enter, home, end or any alphanumeric key) is pressed', () => {
      isOpen = false;
      jest.spyOn(Dropdown.prototype, 'toggle');

      const wrapper = mount(
        <Dropdown isOpen={isOpen} toggle={toggle}>
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu right>
            <DropdownItem>Test</DropdownItem>
            <DropdownItem id="divider" divider />
          </DropdownMenu>
        </Dropdown>, { attachTo: element });

      expect(Dropdown.prototype.toggle.mock.calls.length).toBe(0);
      const event = { preventDefault: ()=>{} };
      const spy = jest.spyOn(event, 'preventDefault');

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.down});
      expect(spy).toHaveBeenCalled();      

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.up});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.esc});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.end});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.home});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: keyCodes.enter});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: 65 /*A key*/});
      expect(spy).toHaveBeenCalled();

      wrapper.find('[aria-haspopup]').hostNodes().simulate('keydown', {...event, which: 90 /*A key*/});
      expect(spy).toHaveBeenCalled();

      wrapper.detach();
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  it('should render different size classes', () => {
<<<<<<< HEAD
    const { rerender } = render(
      <Dropdown group isOpen size="sm">
=======
    const small = mount(
      <Dropdown group isOpen={isOpen} size="sm" toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
<<<<<<< HEAD
      </Dropdown>,
    );

    expect(screen.getByText(/toggle/i).parentElement).toHaveClass(
      'btn-group-sm',
    );

    rerender(
      <Dropdown group isOpen size="lg">
=======
      </Dropdown>
    );

    const large = mount(
      <Dropdown group isOpen={isOpen} size="lg" toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
        <DropdownToggle>Toggle</DropdownToggle>
        <DropdownMenu>
          <DropdownItem>Test</DropdownItem>
        </DropdownMenu>
<<<<<<< HEAD
      </Dropdown>,
    );

    expect(screen.getByText(/toggle/i).parentElement).toHaveClass(
      'btn-group-lg',
    );
=======
      </Dropdown>
    );

    expect(small.find('.btn-group-sm').hostNodes().length).toBe(1);
    expect(large.find('.btn-group-lg').hostNodes().length).toBe(1);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
  });

  describe('Dropdown with nav', () => {
    it('should render a single child', () => {
<<<<<<< HEAD
      testForChildrenInComponent(Dropdown);
    });

    it('should render multiple children when isOpen', () => {
      render(
        <Dropdown nav isOpen>
=======
      const wrapper = mount(<Dropdown nav isOpen={isOpen} toggle={toggle}>Ello world</Dropdown>);

      expect(wrapper.find('.nav-item').hostNodes().text()).toBe('Ello world');
      expect(wrapper.find('.nav-item').hostNodes().length).toBe(1);
    });

    it('should render multiple children when isOpen', () => {
      isOpen = true;
      const wrapper = mount(
        <Dropdown nav isOpen={isOpen} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
<<<<<<< HEAD
        </Dropdown>,
      );

      expect(screen.getByText(/test/i)).toBeInTheDocument();
      expect(screen.getByText(/toggle/i)).toBeInTheDocument();
=======
        </Dropdown>
      );

      expect(wrapper.find('.btn').hostNodes().text()).toBe('Toggle');
      expect(wrapper.find('.nav-item').hostNodes().length).toBe(1);
      expect(wrapper.find('.dropdown-item').hostNodes().length).toBe(1);
      expect(wrapper.find('.nav-item').hostNodes().children().length).toBe(2);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('Dropdown in navbar', () => {
    it('should open without popper with inNavbar prop', () => {
<<<<<<< HEAD
      render(
        <Dropdown nav inNavbar>
          <DropdownToggle caret nav>
            Toggle
          </DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      expect(screen.getByText(/toggle/i).tagName).toBe('A');
      expect(screen.getByText(/test/i).parentElement.tagName).toBe('DIV');
=======
      isOpen = true;
      const wrapper = mount(
        <Dropdown nav inNavbar isOpen={isOpen} toggle={toggle}>
          <DropdownToggle caret nav>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(wrapper.find('.dropdown-toggle').first().type()).toEqual('a');
      expect(wrapper.find('.dropdown-menu').first().type()).toEqual('div');
    });

    it('should open with popper without inNavbar prop', () => {
      isOpen = true;
      const wrapper = mount(
        <Dropdown nav isOpen={isOpen} toggle={toggle}>
          <DropdownToggle caret nav>Toggle</DropdownToggle>
          <DropdownMenu>
            <DropdownItem>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(wrapper.find('.dropdown-toggle').parent().type()).toEqual(Reference);
      expect(wrapper.find('.dropdown-menu').parent().type()).toEqual(Popper);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  describe('active', () => {
    it('should render an active class', () => {
<<<<<<< HEAD
      render(<Dropdown active nav />);

      expect(screen.getByRole('listitem')).toHaveClass('active');
    });

    it('should render an active class when a child DropdownItem is active IF setActiveFromChild is true', () => {
      render(
        <Dropdown nav inNavbar setActiveFromChild>
=======
      const wrapper = shallow(<Dropdown active nav />);

      expect(wrapper.childAt(0).childAt(0).hasClass('active')).toBe(true);
    });

    it('should render an active class when a child DropdownItem is active IF setActiveFromChild is true', () => {
      const wrapper = shallow(
        <Dropdown nav inNavbar setActiveFromChild toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle nav caret>
            Options
          </DropdownToggle>
          <DropdownMenu>
<<<<<<< HEAD
            <DropdownItem active>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      expect(screen.getByRole('listitem')).toHaveClass('active');
=======
            <DropdownItem active>
              Test
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(wrapper.childAt(0).childAt(0).hasClass('active')).toBe(true);
>>>>>>> babce7e82dc134320378dfce834b316b88320254
    });
  });

  it('should render with correct class when direction is set', () => {
<<<<<<< HEAD
    const { rerender } = render(<Dropdown direction="up" nav />);
    expect(screen.getByRole('listitem')).toHaveClass('dropup');
    rerender(<Dropdown direction="start" nav />);
    expect(screen.getByRole('listitem')).toHaveClass('dropstart');
    rerender(<Dropdown direction="end" nav />);
    expect(screen.getByRole('listitem')).toHaveClass('dropend');
  });

  describe('menuRole prop', () => {
    it('should set correct roles for children when menuRole is menu', () => {
      render(
        <Dropdown menuRole="menu" isOpen>
=======
    const dropup = shallow(<Dropdown direction="up" />);
    const dropleft = shallow(<Dropdown direction="left" />);
    const dropright = shallow(<Dropdown direction="right" />);

    expect(dropup.childAt(0).childAt(0).hasClass('dropup')).toBe(true);
    expect(dropleft.childAt(0).childAt(0).hasClass('dropleft')).toBe(true);
    expect(dropright.childAt(0).childAt(0).hasClass('dropright')).toBe(true);
  });

  describe('menuRole prop', () => {

    it('should set correct roles for children when menuRole is menu', () => {
      const wrapper = mount(
        <Dropdown menuRole={'menu'} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle nav caret>
            Options
          </DropdownToggle>
          <DropdownMenu>
<<<<<<< HEAD
            <DropdownItem active>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      expect(screen.getByText(/options/i)).toHaveAttribute(
        'aria-haspopup',
        'menu',
      );
      expect(screen.getByRole('menu')).toBeInTheDocument();
      expect(screen.getByRole('menuitem')).toBeInTheDocument();
    });

    it('should set correct roles for children when menuRole is menu', () => {
      render(
        <Dropdown menuRole="listbox" isOpen>
=======
            <DropdownItem active>
              Test
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(wrapper.props().menuRole).toEqual('menu')
      expect(wrapper.find('[aria-haspopup="menu"]').length).toEqual(1)
      expect(wrapper.find('[role="menuitem"]').length).toEqual(1)
      expect(wrapper.find('[role="menu"]').length).toEqual(1)
    })

    it('should set correct roles for children when menuRole is menu', () => {
      const wrapper = mount(
        <Dropdown menuRole={'listbox'} toggle={toggle}>
>>>>>>> babce7e82dc134320378dfce834b316b88320254
          <DropdownToggle nav caret>
            Options
          </DropdownToggle>
          <DropdownMenu>
<<<<<<< HEAD
            <DropdownItem active>Test</DropdownItem>
          </DropdownMenu>
        </Dropdown>,
      );

      expect(screen.getByText(/options/i)).toHaveAttribute(
        'aria-haspopup',
        'listbox',
      );
      expect(screen.getByRole('option')).toBeInTheDocument();
      expect(screen.getByRole('listbox')).toBeInTheDocument();
    });
  });
=======
            <DropdownItem active>
              Test
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>
      );

      expect(wrapper.props().menuRole).toEqual('listbox')
      expect(wrapper.find('[aria-haspopup="listbox"]').length).toEqual(1)
      expect(wrapper.find('[role="option"]').length).toEqual(1)
      expect(wrapper.find('[role="listbox"]').length).toEqual(1)
    })
  })
>>>>>>> babce7e82dc134320378dfce834b316b88320254
});
